/**
 * AssetDescs are wrappers on extents that have been validated by an DescOps, and
 * can be verified as having been issued by the DescOps. They contain their
 * extent and a Label. The label identifies a particular assay.
 */
struct AssetDesc (Extent, Label) {
  label :Label;
  extent :Extent;
}

/**
 * Quantities describe the extent of something that can be owned or shared.
 * The format is determined by its descOps. Fungible extents are normally
 * represented by natural numbers. Other extents may be represented as
 * strings naming a particular right, or an arbitrary object that sensibly
 * represents the rights at issue. All AssetDescs made by the same DescOps have the
 * same label.
 *
 * Extent must be Comparable. (This IDL doesn't yet provide a way to specify
 * subtype relationships for structs.)
 */
struct Extent {
}

/**
 * Creator and validator of asset AssetDescs.
 *
 * AssetDescs are the canonical description of tradable goods. They are manipulated
 * by mints, and represent the goods and currency carried by purses and
 * payments. They can be used to represent things like currency, stock, and the
 * abstract right to participate in a particular exchange.
 *
 * The descOps treats the Label as an opaque object. It's used in the
 * assetDescs produced by this descOps.
 */
interface DescOps (AssetDesc (Extent, Label)) {

  /** Return this descOps's label. */
  getLabel() -> (Label);

  /** Make a new verified AssetDesc containing the allegedExtent. */
  make(allegedExtent :Extent) -> (AssetDesc);

  /**
   * Is this like an AssetDesc object made by this DescOps, such as one received by
   * pass-by-copy from an otherwise-identical remote AssetDesc? If so, return an
   * AssetDesc object made by this DescOps. Otherwise error.
   *
   * For fungible assetDescs based on natural numbers, coerce also accepts a bare
   * number which it will coerce to a labeled number via descOps.make().
   */
  coerce(allegedAssetDesc :AssetDesc) -> (AssetDesc);

  /** Return a Extent representing the AssetDesc parameter. */
  extent(assetDesc :AssetDesc) -> (Extent);

  /** Return an empty assetDesc. Conveys no authority. */
  empty() -> (AssetDesc);

  /** Return true if the AssetDesc is empty. Otherwise false. */
  isEmpty(assetDesc :AssetDesc) -> (boolean);

  /** Returns true if the leftAssetDesc contains the rightAssetDesc. */
  includes(leftAssetDesc :AssetDesc, rightAssetDesc :AssetDesc) -> (boolean);

  /** 
   * Returns true if the leftAssetDesc equals the rightAssetDesc. We assume
   * that if includes is true in both directions, equals is also true 
   */
  equals(leftAssetDesc :AssetDesc, rightAssetDesc :AssetDesc) -> (boolean);

  /**
   * Returns a new assetDesc that includes both leftAssetDesc and rightAssetDesc.
   *
   * For fungible assetDescs this means adding the extents. For other kinds of
   * assetDescs, it usually means including both.
   */
  with(leftAssetDesc :AssetDesc, rightAssetDesc :AssetDesc) -> (AssetDesc);

  /**
   * Returns a new assetDesc that includes the portion of leftAssetDesc not included
   * in rightAssetDesc. If leftAssetDesc doesn't include rightAmout, throw an error.
   */
  without(leftAssetDesc :AssetDesc, rightAssetDesc :AssetDesc) -> (AssetDesc);
}

/**
 * The label for an assetDesc identifies the assay, and includes a description of
 * the rights it represents.
 *
 * Every assetDesc created by the DescOps will have the same label, but recipients
 * cannot use the label by itself to verify that a purported assetDesc is
 * authentic, since the label can be copied. 
 */
struct Label {
  assay :Assay;
  description :Description;
}

/**
 * Human-readable description of a kind of rights.
 *
 * The Descriptions must be Comparables. (This IDL doesn't yet provide a way to
 * specify subtype relationships for structs.)
 */
struct Description {
}

/**
 * UniDescOps represents assetDescs that have unique descriptions. It is a
 * refinement of DescOps that we've found useful, but has no special
 * place in the protocol.
 *
 * The extent must either be null, in which case it is empty, or be some
 * truthy comparable value, in which case it represents a single unique unit
 * described by that truthy extent. Combining two uni assetDescs with different
 * truthy extents fails, as they represent non-combinable rights.
 */
interface UniDescOps extends (DescOps) {
}

/**
 * DescOps for a labeled natural number describing a extent of fungible
 * erights. The label describes what kinds of rights these are. NatDescOps is a
 * refinement of DescOps that we've found useful, but has no special place in the
 * protocol.
 *
 * Empty assetDescs have zero units. 'includes()' verifies that leftAssetDesc is
 * greater than or equal to rightAssetDesc. 'with()' and 'without()' add and
 * subtract their contents.
 */
interface NatDescOps extends (DescOps) {
}
