// Scooter, The Smart Contract for Object-oriented, Offer-safe,
// Trade of ERights

// ********* Visible to players of a contract *************

/**
 * OfferDescription
 *
 * The stable properties of a given offer.
 *
 * Should grant no authority beyond access to Issuers.
 */
struct OfferDescription {
    /** Index into ScooterTerms.issuers */
    offeredSide :Nat;
    /** Index into ScooterTerms.issuers */
    neededSide :Nat;
    /** Offering at most this amount... */
    offeredAmount :Amount;
    /** ...in exchange for at least this amount */
    neededAmount :Amount;
}

/**
 * OfferStatus
 *
 * A snapshot of the status of an offer. The driver also uses
 * OfferStatus to request a change to the status of an offer.
 *
 * Should grant no authority beyond access to Issuers.
 */
struct OfferStatus {

    /**
     * Initially 'placed'. After that, as arbitrary string set by the
     * driver.
     */
    offerState :String;

    /**
     * The balances of the purses associated with this offer, in order
     * according to ScooterTerms.issuers. On departure, this becomes
     * the final exit balances, paid out in exitPayments.
     *
     * At every moment, either balances[offeredSide] is at least
     * offeredAmount, or balances[neededSide] is at least
     * neededAmount, or both. If exiting when balances[offeredSide] is
     * at least offeredAmount, then at least offeredAmount is
     * refunded. If exiting when balances[neededSide] is at least
     * neededAmount, then at least neededAmount is won.
     */
    balances :List(Amount);

    /**
     * Is this offer still in the Scooter pool, or has it already
     * exited? If it has exited, the offerState should indicate
     * why. When the driver requests a new status with this set to
     * false, it is requesting that this offer be ejected from the
     * pool, while paying out the exit balances stated in this same
     * status request.
     */
    isInPool :Boolean;
}

/**
 * OfferHandle
 *
 * The capability to operate a given offer, obtained by successully
 * placing the offer.
 */
interface OfferHandle {

    /**
     * Always the same for a given offer
     */
    describe() -> (OfferDescription);

    /**
     * A snapshot of the offer's current status.
     */
    getCurrentStatus() -> (OfferStatus);

    /**
     * A promise for a list of Payments, in order according to
     * ScooterTerms.issuers. Will be fulfilled on exit to payments for
     * the final exit balances.
     */
    getExitPayments() -> (Promise(List(Payment)));

    /**
     * Notify the driver's sentry that this offer wishes to collect
     * its exit payments and leave the pool. It is up to the sentry
     * how to react to this request. Thus, even for simple exit
     * behaviors, like exit-at-will, the driver can update its own
     * state before honoring the request.
     *
     * Return a promise for an arbitrary string returned by
     * sentry.noticeExitRequested.
     */
    requestExit() -> (Promise(String));
}

/**
 * OfferSeat
 *
 * The invitation to place an offer is redeemed for an OfferSeat,
 * which is used to actually place the offer. Thus, the player, having
 * validated the invite is to a scooter, knows that it is sharing
 * direct access to the actual erights only with scooter itself.
 */
interface OfferSeat {

    getOfferedSide() :Nat;
    getNeededSide() :Nat;

    /**
     * Place an offer by offering at most all the erights in
     * offeredPayment in exchange for at least the neededAmount.
     * Scooter will first escrow those erights, and only then fulfill
     * the returned promise for the OfferHandle. It will then also
     * notify the driver's sentry of the new offer.
     *
     * Until the driver's sentry.noticeOfferEntry receives the
     * notification, it does not know the offerId of this offer, and
     * so is insentitive to whether the offer has yet been
     * placed. Thus, the driver can update its own state before taking
     * further action on these entry notifications.
     *
     * The sentry can thus effectively refuse entry to the new offer
     * by ejecting it from the pool rather than updating its own state
     * to include the offer.
     */
    placeOneOffer(offerPayment :Presence(Payment),
                  neededAmount :Amount) -> (Promise(OfferHandle));
}

// ********* Visible only to Scooter and the Driver ***********

/**
 * OfferId
 *
 * How Scooter and the driver refer to offers placed into this scooter
 * pool.
 */
interface OfferId {}

/**
 * Scooter
 *
 * A scooter instance represents a pool of offers, each with escrowed
 * erights, that enforces offer safety, i.e., that the terms of the
 * offers will be honored. 
 *
 * Only the driver should have direct access to its scooter
 * instance. A scooter is completely passive. It is driven only by the
 * driver's calls to scooter.updateOffers.
 */
interface Scooter {

    /**
     * Make an invitation to place one offer, offering the erights
     * described by ScooterTerms.issuers[offeredSide]. Once this offer
     * is placed, the sentry callback is notified.
     *
     * Returns the invitation payment to be redeemed for an OfferSeat
     * to use to place an offer.
     */
    inviteToPlaceOffer(sentry :Presence(Sentry),
                       offeredSide :Nat,
                       neededSide :Nat) -> Invite(OfferSeat);

    /**
     * Given a list of OfferIds, return a corresponding list of
     * OfferDescriptions. Error if any offer is not in the pool.
     */
    describeOffers(offerIds :List(OfferId)) -> (List(OfferDescription));

    /**
     * Given a list of OfferIds, return a corresponding list of
     * OfferStatuses as an atomic snapshot. Error if any offer is not
     * in the pool.
     */
    getOfferStatuses(offerIds :List(OfferId)) -> (List(OfferStatus));

    /**
     * First, validate that offerUpdates is a valid update to the
     * offer statuses. If so, then atomically update these
     * statuses. For each status updated with {isInPool: false}, pay
     * its updated final balance as its exit payments and then eject
     * it from the pool.
     *
     * As a convenience, updateOffers returns the remaining live
     * OfferIds, i.e., omitting those who exited.
     */
    updateOffers(offerIds :List(OfferId),
                 offerUpdates :List(OfferStatus)) -> (List(OfferId));
}

/**
 * Sentry
 *
 * The callback interface provided by the driver, for scooter to
 * notify of a newly placed offer and of a request to exit.
 */
interface Sentry {

    /**
     * This is how the driver is notified that an offer has been
     * placed in the pool. The offerId uniquely names this
     * offer. Without it, scooter is insensitive to the presence of
     * this offer.
     */
    noticeOfferEntered(offerId :OfferId,
                       offerDescription :OfferDescription,
                       initialStatus :OfferStatus) -> (oneway);

    /**
     * This method's behavior expresses the cancellation policy for
     * exiting the pool. An exit-at-will policy would update the
     * driver's bookkeeping and ask scooter to eject the offer. A no
     * exit before deadline policy would reject these offers before
     * the deadline and then honor them after the deadline.
     */
    noticeOfferExitRequested(offerId :OfferId) -> (String);
}

/**
 * ScooterTerms
 *
 * The `issuers` is a list of at least two Issuers, for bringing about
 * trades of the erights issued by these issuers.
 */
struct ScooterTerms {
    issuers :List(Presence(Issuer));
}

/**
 * ScooterContract
 */
interface ScooterContract extends (Contract) {

    /**
     * 
     */
    start(terms :ScooterTerms, inviteMaker :InviteMaker) -> (Promise(Scooter));
}
