// Scooter, The Smart Contract for Object-oriented, Offer-safe,
// Transactional ERights

// ********* Visible to players of a contract *************

/**
 * OfferDescription
 *
 * The stable properties of a given offer.
 *
 * Should grant no authority beyond access to Issuers.
 */
struct OfferDescription {
    /** Index into ScooterTerms.issuers */
    offeredSide :Nat;
    /** Index into ScooterTerms.issuers */
    neededSide :Nat;
    /** Offering at most this amount... */
    offeredAmount :Amount;
    /** ... in exchange for at least this amount */
    neededAmount :Amount;
}

/**
 * OfferStatus
 *
 * A snapshot of the status of an offer. The governing contract also
 * uses OfferStatus to request a change to the status of an offer.
 *
 * Should grant no authority beyond access to Issuers.
 */
struct OfferStatus {

    /**
     * Initially 'placed'. After that, as arbitrary string set by the
     * governing contract.
     */
    offerState :String;

    /**
     * The balances of the purses associated with this offer, in order
     * according to ScooterTerms.issuers. On departure, this becomes
     * the final exit balances, paid out in exitPayments.
     *
     * At every moment, either balances[offeredSide] is at least
     * offeredAmount, or balances[neededSide] is at least
     * neededAmount, or both. If exiting when balances[offeredSide] is
     * at least offeredAmount, then at least offeredAmount is
     * refunded. If exiting when balances[neededSide] is at least
     * neededAmount, then at least neededAmount is won.
     */
    balances :List(Amount);

    /**
     * Is this offer still in the Scooter pool, or has it already
     * exited? If it has exited, the offerState should indicate why.
     */
    isInPool :Boolean;
}

/**
 * OfferHandle
 *
 * The capability to operate a given offer, obtained by successully
 * placing the offer.
 */
interface OfferHandle {

    /**
     * Always the same for a given offer
     */
    describe() -> (OfferDescription);

    /**
     * A snapshot of the offer's current status.
     */
    getCurrentStatus() -> (OfferStatus);

    /**
     * A promise for a list of Payments, in order according to
     * ScooterTerms.issuers. Will be fulfilled on exit to payments for
     * the final exit balances.
     */
    getExitPayments() -> (Promise(List(Payment)));

    /**
     * Notify the governing contract's sentry that this offer wishes
     * to collect its exit payments and leave the pool. It is up to
     * the governing contract's sentry how to react to this
     * request. Thus, even for simple exit behaviors, like
     * exit-at-will, the governing contract can update its own state
     * before honoring the request.
     *
     * Return a promise for an arbitrary string returned by
     * sentry.noticeExitRequested.
     */
    requestExit() -> (Promise(String));
}

/**
 * OfferPlacer
 *
 * The invitation to place an offer is redeemed with an OfferPlacer,
 * which then must be used to actually place the offer. Thus, the
 * player, having validated the invite, knows that it is sharing
 * direct access to the actual erights only with scooter itself.
 */
interface OfferPlacer {

    getOfferedSide() :Nat;
    getNeededSide() :Nat;

    /**
     * Place an offer by offering at most all the erights in
     * offeredPayment in exchange for at least the neededAmount.
     * Scooter will first escrow those erights, and only then fulfill
     * the returned promise for the OfferHandle. It will then also
     * notify the governing contract's sentry of the new offer.
     *
     * Until the governing contract's sentry.noticeOfferEntry receives
     * the notification, it can safely treat a placed offer that it
     * has not yet been notified of identically to an invited offer
     * that has not yet been placed. Thus, it can update its own state
     * before taking further action on these entry notifications.
     *
     * The sentry can thus effectively refuse entry to the new offer
     * by removing it from the pool rather than updating its own
     * state.
     */
    placeOneOffer(offerPayment :Eventual(Payment),
                  neededAmount :Amount) -> (Promise(OfferHandle));
}

// ********* Visible to the governing contract *************

/**
 * OfferId
 *
 * How Scooter and the governing contract refer to offers placed, or
 * to be placed, into this scooter pool.
 */
interface OfferId {}

/**
 * Scooter
 *
 * A scooter instance represents a pool of offers, each with escrowed
 * erights, that enforces offer safety, i.e., that the terms of the
 * offers will be honored. 
 *
 * Only the governing contract should have direct access to its
 * scooter instance. A scooter is completely passive. It is driven
 * only by the governing contract's calls to scooter.updateOffers.
 */
interface Scooter {

    /**
     * Make an invitation to place one offer, offering the erights
     * described by ScooterTerms.issuers[offeredSide].
     *
     * Returns a pair of the invitation itself and the OfferId that
     * will identify the to-be-placed offer. The OfferId enables the
     * governing contract to know which entry notifications correspond
     * to which invitation.
     */
    inviteToPlaceOffer(offeredSide :Nat) -> (Invite(OfferPlacer), OfferId);

    /**
     * Given a list of OfferIds, return a corresponding list of
     * OfferDescriptions. Error if any offer is not in the pool.
     */
    describeOffers(offerIds :List(OfferId)) -> (List(OfferDescription));

    /**
     * Given a list of OfferIds, return a corresponding list of
     * OfferStatuses. Error if any offer is not in the pool. This is
     * an atomic snapshot.
     */
    getOfferStatuses(offerIds :List(OfferId)) -> (List(OfferStatus));

    /**
     * First, validate that offerUpdates is a valid update to the
     * offer statuses. If so, then atomically update these
     * statuses. For each status updated with isInPool: false, pay its
     * updated final balance as its exit payments and then remove it
     * from the pool.
     *
     * Returns the remaining live OfferIds, i.e., omitting those who
     * exited.
     */
    updateOffers(offerIds :List(OfferId),
                 offerUpdates :List(OfferStatus)) -> (List(OfferId));
}

/**
 * Sentry
 *
 * The callback interface provided by the governing contract, to
 * notify it of new entrants and requests to exit.
 */
interface Sentry {

    /**
     */
    noticeOfferEntered(offerId :OfferId) -> (oneway);

    /**
     */
    noticeOfferExitRequested(offerId :OfferId) -> (String);
}

/**
 * ScooterTerms
 */
struct ScooterTerms {
    issuers :List(Eventual(Issuer));
    sentry :Eventual(Sentry);
}

/**
 * ScooterContract
 */
interface ScooterContract extends (Contract) {

    /**
     */
    start(terms :ScooterTerms,
          inviteMaker :InviteMaker) -> (Promise(Invite(Scooter)));
}
