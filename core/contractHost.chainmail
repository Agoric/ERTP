/**
 * ContractHost provides a way to install and run verifiable contracts.
 *
 * Install(source) creates Installations. Installations represent particular
 * contract forms, which can be spawn()'d to create Contract instances
 * initialized with specific terms. These Contracts manage invitations for
 * multiple seats, each of which repesents a role in an transaction. After a
 * role has carried out its responsibilities, it may call collect() (described
 * later) to collect winnings and refunds into appropriate purses.
 */
interface ContractHost {
  /**
   * ContractSrc is the source code for a Contract. See Contract for details.
   */
  install(contractSrc:Text) -> (Installation);

  /** Returns the actual source of the Installation. */
  getInstallationSourceCode(installation:Installation) -> (Text);

  /**
   * Seat invitations are packaged as payments from the Invite
   * Issuer. Redeeming an invite returns a role object with an arbitrary
   * interface (the interface is at the discretion of the contract) which
   * supports interaction according to the terms.
   */
  redeem(invite:Payment) -> (Object); // can we say more about the returned value?

  /**
   * The issuer allows holders of seat invites to get exclusive access to a
   * Seat.
   */
  getInviteIssuer() -> (Issuer);
};

/**
  * An installation of a Contract can spawn multiple copies each with the same
  * or different terms. Each spawned instance has distinct invites and distinct
  * seats representing a specific group of players interacting according to the
  * same prescribed roles.
  *
  * spawn() creates a new InviteMaker, and calls the Contract's start() method
  * returning its results (expected to be a collection of seat invites for the
  * roles in the contract, but see coveredCall for an exception).
  *
  * The Installation can also have functions with names starting `check`, as
  * defined by the contract. These functions are intended to assist the various
  * roles in the contract in validating that the terms they're expecting are
  * actually the same as the terms of this spawned contract. The Installation
  * is inserted as the first parameter to the check... functions by the
  * ContactHost.
  */
interface Installation {
  spawn(terms:Terms) -> (invites:Object); // usually a collection of seat Invites
};

/**
  * Contracts are pass-by-text.
  * 
  * The ContractHost wants 'install()' to be called on an object with a start()
  * method. In order to be able to verify to those relying on the contract that
  * it implements the source code that they expect, the ContractHost needs to
  * create the contract object by calling evaluate() on the source code.
  *
  * Javascript gives access to the source from a function, but not from an
  * object. We make the source accessible to the ContractHost by having
  * contracts export a record containing the source.
  * 
  * The form of the 'terms' argument to the contract's start() method is also
  * completely up to the individual contract. It should represent all the
  * information a participant needs in order to know they're participating in
  * the contract they intended. 'escrow' represents a simple exchange of one
  * bundle of goods for another. The terms object has the 'amount's to be
  * traded as 'left' and 'right', which correspond to the amounts being offered
  * and collected by the respective parties. This representation is flexible
  * enough to support trading of money, non-fungible items, or
  * partially-executed positions in other contracts.
  */
interface Contract {
  start(terms:Terms, inviteMaker:InviteMaker) -> (Object);
  
  checkAmount(inviteAmount, terms); 
}

/**
  * 
  * An InviteMaker is provided to contracts as a parameter to `start()`. It
  * allows the contract to issue invitations for 'seats', arbitrary objects
  * whose interface defines the roles and interactions in the contract. The
  * design of the InviteMaker, allows recipients of invites to validate that
  * the invite corresponds to the role and contract that they expected.
  * 
  * 'seatDesc' can be any truthy object, but Strings are convenient. They must
  * be unique for each contract instantiation. 'seat' is an arbitrary object
  * defined by the contract. 'name' is optional; it is used to label the invite
  * payment corresponding to the seat.
  */
interface InviteMaker {
  make(seatDesc:String, seat:Object, name:String) -> (Purse);
}

/**
  * 'collect()' is a free function that can be imported from
  * 'contractHost.js'. It calls getWinnings() and 'getRefund()' on seatP and
  * deposits the proceeds respectively into winPurseP and refundPurseP. 'name'
  * (which defaults to 'collecting') is converted to a String, and used for
  * logging the results. This establishes that the normal outcome of a contract
  * is made available by providing getWinnings() and getRefunds() methods on
  * the seats defined by the contract.
  */
interface Collector {
  collect(seatP:Object, winPurseP:Purse, refundPurseP:Purse, name:String)
    -> ([wins, refs]);
}
o