/**
 * 
 * Holding an Issuer provides the ability to create amounts and empty purses,
 * but confers no rights. It is also the mechanism used to get exclusive access
 * to a Purse or Payment, or to burn some or all of the contained rights.
 */
interface Issuer {
  /* Get the label for this Issuer.
   * 
   * Labels can be used to manually construct amounts 
   */
  getLabel() -> (Object);

  /* Get the Assay for this Issuer. */
  getAssay() -> (Assay);

  /** Make an Amount that contains the indicated quantity. */
  makeAmount(quantity:Quantity) -> (Amount);

  /** Make an empty purse associated for this kind of right. */
  makeEmptyPurse(name:String) -> (Purse);

  /**
   * Make a new Payment that has exclusive rights to the amount, only if the
   * Purse had those rights, exclusively or not.
   */
  getExclusive(amount:Amount, src:Purse, name:String = 'a payment') -> (Payment);

  /**
   * Make a new Payment that has exclusive rights to all the contents of the
   * purse.
   */
  getExclusiveAll(src:Purse, name:String = 'a payment') -> (Payment);

  /**
   * Burn (remove) amount of the rights from src. If the rights are fungible,
   * this directly removes the rights from the payment, while if the rights are
   * non-fungible, this ensures that no purse or payment has access to those
   * rights.
   */
  burn(amount:Amount, src:Payment);

  /** Burn (remove) all of the rights from src. */
  burnAll(src:Payment);
}

/**
 * Makes Mints.
 * 
 * The description becomes part of the label, used by the assay to identify
 * amounts authorized/acknowledged by the mint. The MintController and Assay
 * must be compatible with the type of asset managed by the mint.
 * 
 * Description doesn't have to be a string, but it will only be used for its
 * value.
 */
interface MintMaker {
  makeMint(
      description:String,
      makeMintController:MintControllerMaker,
	  makeAssay:AssayMaker)
	-> (Mint);
}

/**
 * Holding a Mint gives the exclusive right to control issuance and destruction
 * of Purses containing amounts of a particular currency. Purses (and payments)
 * associated with the issuer will only interact with others using the same
 * mint.
 */
interface Mint {
  /** Get the Issuer for this mint. */
  getIssuer() -> (Issuer);

  /**
   * Create a new Purse containing the amount. Give it the specified name or "a
   * purse".
   */
  mint(initialBalance:Amount, name:String = 'a purse') -> (Purse);

  /** Reset all purses and payments to contain nothing. */
  destroyAll();

  /** (Non-fungible amounts only) Ensure no purse or payment contains amount. */
  destroy(amount:Amount);

  /**
   * Destroy any purses or payments containing amount, then issue a new Purse
   * with that amount.
   */
  revoke(amount:Amount) -> (Purse);
}

/**
 * Purses hold verified amounts of certain rights issued by Mints. Purses can
 * transfer part of the balance they hold in a payment, which has a narrower
 * interface. A purse's balance can rise and fall, through the action of
 * deposit() and withdraw(), while payments don't accept deposits, but can be
 * reduced with burn() or by passing them as a parameter to deposit().
 *
 * The primary use for Purses and Payments is for currency-like and goods-like
 * valuables, but they can also be used to represent other kinds of rights, such
 * as the right to participate in a particular contract.
 *
 * Currency-like assets are fungible, and don't distinguish use rights from
 * transfer rights. The only use of a currency is to spend it. Some goods
 * distinguish use rights from transfer rights, like a membership card; you can
 * exercise the rights without giving them up.
 */
interface Purse extends (PurseOrPayment) {
  /** Get the Issuer for this mint. */
  getIssuer() -> (Issuer);
  getXferBalance() -> (Amount);
  getUseBalance() -> (Amount);
  deposit(amount:Amount, srcPayment:PurseOrPayment) -> (Amount);
  depositAll(srcPayment:PurseOrPayment) -> (Amount);
  withdraw(amount:Amount, name:String) -> (Payment);
  withdrawAll(name:String) -> (Payment);
}

/**
 * Payments hold verified amounts of certain rights issued by Mints. Amounts
 * from payments can be deposited in purses, but otherwise, the entire amount is
 * available when the payment is transferred. A payment's balance can only fall,
 * through the action of deposit() or burn().
 * 
 * Payments can be converted to Purses by calling
 * payment.getIssuer().makeEmptyPurse().depositAll(payment);
 */
interface Payment extends (PurseOrPayment) {
  getIssuer() -> (Issuer);
  getXferBalance() -> (Amount);
}

/**
 * PurseOrPayment is the parent type of Purse and Payment. Most interfaces only
 * accept one of the sub-types to reduce the incidence of the common mistake of
 * giving away a purse when you meant to hold on to the purse and give away part
 * of the contents. deposit() and depositAll() are the two exceptions, for which
 * the caller explicitly says to give up all contained rights, or provides an
 * explicit amount to transfer.
 */
interface PurseOrPayment {
  getIssuer() -> (Issuer);
  getXferBalance() -> (Amount);
}

/** MintController records the amounts contained by purses. */
interface MintController {
  /**
   * (Non-fungible amounts only.) Ensure no purse or payment contains amount.
   */
  destroy(amount:Amount);

  /** Reset all purses to contain nothing. */
  destroyAll();

  /**
   * Record that payment is a new Payment containing amount, and that src
   * now contains srcNewRightsAmount.
   */
  recordPayment(
    src:Purse, payment:Payment, amount:Amount, srcNewRightsAmount:Amount);

  /**
   * Record that srcPayment now contains srcNewRightsAmount, and purse is a new
   * Purse containing purseNewRightsAmount.
   */
  recordDeposit(
    src:PurseOrPayment,
	srcNewRightsAmount:Amount,
	purse:Purse,
	purseNewRightsAmount:Amount);

  /**
   * Record that purse is a new Purse containing srcNewRightsAmount.
   */
  recordMint(purse:Purse, initialAmount:Amount);

  /** Return the Amount contained in purse. */
  getAmount(purse:Purse) -> (Amount);
}
