/**
 * Creator and validator of asset Amounts.
 * 
 * Amounts are the canonical description of tradable goods. They are manipulated
 * by mints, and represent the goods and currency carried by purses and
 * payments. They can be used to represent currency, stock, or the abstract
 * right to participate in a particular exchange.
 * 
 * Assays distinguish between Quantities and Amounts. Quantities describe the
 * extent of something that can be owned or shared, while Amounts are wrappers
 * on those Quantities that have been validated by the Assay, and can be
 * verified as having been issued by the Assay.  All Amounts made by the same
 * Assay have the same label.
 * 
 * Quantities include natural numbers representing how much of a fungible good
 * is being discussed, arbitrary objects describing particular non-fungible
 * goods, or names representing abstract rights.
 */
interface Assay {

  /** Human readable name for the asset. */
  getLabel() -> (String);

  /** Make a new verified Amount containing the allegedQuantity. */
  make(allegedQuantity:Quantity) -> (Amount);

  /**
   * Verify that an Amount was created by this Assay. Notice that this is
   * different from coerce(), which will accept manually constructed amounts and
   * amounts from other assays with the same label.
   */
  vouch(amount:Amount) -> (Amount);

  /**
   * Is this like an Amount object made by this Assay, such as one received by
   * pass-by-copy from an otherwise-identical remote Amount? On success, return
   * an Amount object made by this Assay. Otherwise error.
   * 
   * For fungible amounts based on natural numbers, coerce also accepts a bare
   * number which it will coerce to a labeled number via assay.make().
   */
  coerce(allegedAmount:Amount) -> (Amount);

  /** Return the Quantity contained in the Amount parameter. */
  quantity(amount:Amount) -> (Quantity);

  /** Return an empty amount. Conveys no authority. */
  empty() -> (Amount);

  /** Return true if the Amount is empty. Otherwise false. */
  isEmpty(amount:Amount) -> (boolean);

  /** Returns true if the leftAmount contains the rightAmount. */
  includes(leftAmount:Amount, rightAmount:Amount) -> (boolean);

  /** Returns a new amount that includes both leftAmount and rightAmount. */
  with(leftAmount:Amount, rightAmount:Amount) -> (Amount);

  /**
   * Returns a new amount that includes the portion of leftAmount not included
   * in rightAmount. If leftAmount doesn't include rightAmout, throw an error.
   */
  without(leftAmount:Amount, rightAmount:Amount) -> (Amount);
};

/** 
 * UniAssay represents amounts that have unique descriptions. 
 * 
 * The quantity must either be null, in which case it is empty, or be some
 * truthy comparable value, in which case it represents a single unique unit
 * described by that truthy quantity. Combining two uni amounts with different
 * truthy quantities fails, as they represent non-combinable rights. Distinct
 * amounts can be added to a single purse, producing a purse containing
 * multiple amounts.
 */
interface UniAssay extends (Assay) {
}

/** 
 * Assay for a labeled natural number describing a quantity of fungible
 * erights. The label describes what kinds of rights these are. This is a form
 * of labeled unit, as in unit typing.
 * 
 * Empty amounts have zero units. 'includes()' verifies that leftAmount is
 * greater than rightAmount. 'with()' and 'without()' add and subtract their
 * contents.
 */
interface NatAssay extends (Assay) {
}


